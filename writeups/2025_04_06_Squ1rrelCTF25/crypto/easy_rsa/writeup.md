
https://ctftime.org/event/2708

# Easy RSA (crypto)

“The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the ‘factoring problem’” -Wikipedia

## Analysis

We can see from the following code that `p` and `q` will be close to each other:

```python
def gen_primes(bit_length, diff=2**32):
    p = nextprime(random.getrandbits(bit_length))
    q = nextprime(p + random.randint(diff//2, diff))
    return p, q
```

When a composite number is composed of two primes that are close to each other we can use Fermat's factoring method.

## Solution

```python
#!/usr/bin/env python3

import gmpy2

n = 26518484190072684543796636642573643429663718007657844401363773206659586306986264997767920520901884078894807042866105584826044096909054367742753454178100533852686155634326578229244464083405472076784252798532101323300927917033985149599262487556178538148122012479094592746981412717431260240328326665253193374956717147239124238669998383943846418315819353858592278242580832695035016713351286816376107787722262574185450560176240134182669922757134881941918668067864082251416681188295948127121973857376227427652243249227143249036846400440184395983449367274506961173876131312502878352761335998067274325965774900643209446005663 
e = 65537 
c = 14348338827461086677721392146480940700779126717642704712390609979555667316222300910938184262325989361356621355740821450291276190410903072539047611486439984853997473162360371156442125577815817328959277482760973390721183548251315381656163549044110292209833480901571843401260931970647928971053471126873192145825248657671112394111129236255144807222107062898136588067644203143226369746529685617078054235998762912294188770379463390263607054883907325356551707971088954430361996309098504380934167675525860405086306135899933171103093138346158349497350586212612442120636759620471953311221396375007425956203746772190351265066237

# https://asecuritysite.com/rsa/rsa_01
def FermatFactor(n: int, max_steps: int):
    if n % 2 == 0:
        return 2, n // 2

    a = gmpy2.isqrt(n)

    if a * a == n:
        return a, a

    a += 1  # ceil(sqrt(n))
    b2 = a * a - n

    for _ in range(max_steps):
        if gmpy2.is_square(b2):
            return a + gmpy2.isqrt(b2), a - gmpy2.isqrt(b2)

        b2 += a
        a += 1
        b2 += a
    return None

p, q = FermatFactor(n, 100000000000000)
assert((p * q) == n)

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c, d, n)

flag = m.to_bytes(length=(m.bit_length() + 7) // 8, byteorder="big").decode()
print(flag) # squ1rrel{who's_your_favorite_mathemetician?}
```

## Flag
`squ1rrel{who's_your_favorite_mathemetician?}`
